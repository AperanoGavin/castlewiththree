<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - geometry - cube</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>

<body>

	<script type="module">

		import * as THREE from '../three.js/build/three.module.js';
		import { OrbitControls } from '../three.js/examples/jsm/controls/OrbitControls.js';
		import { CameraControls } from '../three.js/examples/jsm/controls/experimental/CameraControls.js';

		let camera, scene, renderer;
		let plane;
		let pointer, raycaster, isShiftDown = false;
		let rollOverMesh, rollOverMaterial;
		let cubeGeo, cubeMaterial;

		const TextureLoader = new THREE.TextureLoader();
		const grass = TextureLoader.load('textures/grass.jpg');
		const brick = TextureLoader.load('../three.js/examples/textures/brick_bump.jpg');
		const redbrick = TextureLoader.load('textures/Roof_Tiles_Terracotta_006_basecolor.jpg');
		const sky = TextureLoader.load('textures/sky.jpg')
		const tiles = new THREE.MeshLambertMaterial({ map: redbrick });
		const material = new THREE.MeshLambertMaterial({ map: brick });
		const objects = [];

		init();
		render();

		function init() {
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(500, 800, 1300);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = sky;

			//south wall
			let x = -500;
			let y = 25;
			let z = 525;
			createWall(x, y, z, south);

			//north wall
			x = -500;
			y = 25;
			z = -575;
			createWall(x, y, z, "north");

			//west wall
			x = -475;
			y = 25;
			z = -525;
			createWall(x, y, z, "west");

			//east wall
			x = 525;
			y = 25;
			z = -525;
			createWall(x, y, z, "east");

			//south west tower
			x = -400
			y = 50 * 5 / 2
			z = 450
			createTower(x, y, z);

			//south east tower
			x = 450
			y = 50 * 5 / 2
			z = 450
			createTower(x, y, z);

			//north east tower
			x = 450
			y = 50 * 5 / 2
			z = -500
			createTower(x, y, z);

			//north west tower
			x = -400
			y = 50 * 5 / 2
			z = -500
			createTower(x, y, z);

			//central piece
			// var buildingWidth, buildingHeight, buildingDepth

			// var building = new THREE.Mesh(new THREE.CubeGeometry(buildingWidth, buildingHeight, buildingDepth), brick);
			// building.castShadow = true;

			// var frontUpperBuildingPart = createUpperPart();
			// var backUpperBuildingPart = createUpperPart();

			// frontUpperBuildingPart.position.set(0, buildingHeight / 2, buildingDepth / 2);
			// building.add(frontUpperBuildingPart);

			// backUpperBuildingPart.rotation.y = Math.PI;
			// backUpperBuildingPart.position.set(0, buildingHeight / 2, -buildingDepth / 2);
			// building.add(backUpperBuildingPart);

			// var rightRoof = createRoof();
			// var leftRoof = createRoof();

			// rightRoof.position.set(0, buildingHeight, 0);
			// rightRoof.position.y = buildingHeight / 2;
			// building.add(rightRoof);

			// leftRoof.rotation.y = Math.PI;
			// leftRoof.position.y = buildingHeight / 2;
			// building.add(leftRoof);

			// roofGeometry.vertices.push(new THREE.Vector3(buildingWidth / 2, 0, -buildingDepth / 2));
			// roofGeometry.vertices.push(new THREE.Vector3(0, roofHeight, -buildingDepth / 2));
			// roofGeometry.vertices.push(new THREE.Vector3(buildingWidth / 2, 0, buildingDepth / 2));
			// roofGeometry.vertices.push(new THREE.Vector3(0, roofHeight, buildingDepth / 2));

			// roofGeometry.faces.push(new THREE.Face3(0, 1, 2));
			// roofGeometry.faces.push(new THREE.Face3(3, 2, 1));
			// roofGeometry.computeFaceNormals();

			// for (x = -buildingWidth / 2 + windowMargin; x < buildingWidth / 2 - windowMargin; x += windowMargin) {
			// 	wind = createWindow(windowXRadius, windowYRadius, windowMaterial);
			// 	wind.position.set(x, windowY, buildingDepth / 2 + 0.2);
			// 	building.add(wind);
			// }

			// wind = createWindow(8, 24, windowMaterial);
			// wind.position.set(0, 26, buildingDepth / 2 + 0.2);
			// building.add(wind);



			// roll-over helpers

			// const rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
			// rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
			// rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
			// scene.add( rollOverMesh );

			// cubes

			// cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
			// cubeMaterial = new THREE.MeshLambertMaterial( { map: brick } );

			// grid

			// const gridHelper = new THREE.GridHelper( 1500, 20 );
			// scene.add( gridHelper );

			//

			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();

			const ground = new THREE.PlaneGeometry(1500, 1500);
			ground.rotateX(- Math.PI / 2);

			const geometry = new THREE.PlaneGeometry(300, 300);
			geometry.rotateX(-Math.PI / 2);
			x = -550
			y = 0
			z = -500

			for (var i = 0; i < 5; i++) {
				for (var j = 0; j < 5; j++) {
					plane = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ map: grass }));
					plane.position.set(x, y, z);
					if (j % 2 == 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0 && j % 2 != 0) {
						plane.rotateY(Math.PI);
					}

					scene.add(plane);
					x = x + 300
				}

				x = -550
				z = z + 300
			}



			objects.push(plane);

			// lights

			const ambientLight = new THREE.AmbientLight(0x606060);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			document.addEventListener('pointermove', onPointerMove);
			document.addEventListener('pointerdown', onPointerDown);
			document.addEventListener('keydown', onDocumentKeyDown);
			document.addEventListener('keyup', onDocumentKeyUp);

			//

			window.addEventListener('resize', onWindowResize);

		}
		//Central
		// function createUpperPart() {
		// 	var upperPartGeometry = new THREE.Geometry();
		// 	upperPartGeometry.vertices.push(new THREE.Vector3(-buildingWidth / 2, 0, 0));
		// 	upperPartGeometry.vertices.push(new THREE.Vector3(buildingWidth / 2, 0, 0));
		// 	upperPartGeometry.vertices.push(new THREE.Vector3(0, roofHeight, 0));

		// 	upperPartGeometry.faces.push(new THREE.Face3(0, 1, 2));
		// 	upperPartGeometry.computeFaceNormals();

		// 	var upperPart = new THREE.Mesh(upperPartGeometry, wallMaterial);
		// 	upperPart.castShadow = true;

		// 	return upperPart;
		// }

		// function createWindow(xRadius, yRadius, material) {
		// 	var ellipse = new THREE.EllipseCurve(0, 0, xRadius, yRadius, 0, Math.PI);
		// 	var ellipsePath = new THREE.Path(ellipse.getPoints(50));
		// 	var windowGeometry = new THREE.ShapeGeometry(ellipsePath.toShapes()[0]);
		// 	return new THREE.Mesh(windowGeometry, material);
		// }

		function createWall(x, y, z, side) {
			switch (side) {
				case 'north':
					for (var i = 0; i < 3; i++) {
						for (var j = 0; j < 21; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x + 25, y, z);
							x = x + 50;
							scene.add(cube);
						}
						x = -500;
						y = y + 50;
					}
					indent = 1;
					for (var j = 0; j < 21; j++) {
						if (indent % 2 != 0) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x + 25, y, z);
							x = x + 50;
							scene.add(cube);
							indent += 1;
						} else {
							indent += 1;
							x = x + 50
							continue;
						}
					}
					break;

				case 'west':
					for (var i = 0; i < 3; i++) {
						for (var j = 0; j < 21; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z);
							z = z + 50;
							scene.add(cube);
						}
						z = -525;
						y = y + 50;
					}
					indent = 1;
					for (var j = 0; j < 21; j++) {
						if (indent % 2 == 0) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z);
							z = z + 50;
							scene.add(cube);
							indent += 1;
						} else {
							indent += 1;
							z = z + 50
							continue;
						}
					}
					break;

				case 'east':
					for (var i = 0; i < 3; i++) {
						for (var j = 0; j < 21; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z)
							z = z + 50
							scene.add(cube);
						}
						z = -525
						y = y + 50
					}
					for (var j = 0; j < 21; j++) {
						if (indent % 2 != 0) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z);
							z = z + 50;
							scene.add(cube);
							indent += 1;
						} else {
							indent += 1;
							z = z + 50
							continue;
						}
					}
					break;

				case 'south':
					for (var i = 0; i < 3; i++) {
						for (var j = 0; j < 21; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							if (j > 6 && j < 14) {
								if (j == 7 || j == 13) {
									const cube = new THREE.Mesh(wall, material);
									cube.position.set(x + 25, y, z)
									scene.add(cube);
								}
							} else {
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z)
								scene.add(cube);
							}
							x = x + 50;
						}
						x = -500;
						y = y + 50;
					}
					let indent = 1;
					for (var j = 0; j < 21; j++) {
						if (indent % 2 != 0) {
							if (j != 8 && j != 10 && j != 12) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z);
								x = x + 50;
								scene.add(cube);
								indent += 1;
							} else {
								x = x + 50;
								indent += 1;
							}
						} else {
							indent += 1;
							x = x + 50
							continue;
						}
					}
					break;

				default:
					console.log("side not recognized")
			}
		}

		function createTower(x, y, z) {
			const tower = new THREE.CylinderGeometry(50, 50, 50 * 5, 320);
			const cylinder = new THREE.Mesh(tower, material);
			cylinder.position.set(x, y, z);
			scene.add(cylinder);
			y = y + 225
			const cone = new THREE.ConeGeometry(80, 200, 320);
			const roof = new THREE.Mesh(cone, tiles);
			roof.position.set(x, y, z);
			scene.add(roof);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();

		}

		function onPointerMove(event) {
			pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(pointer, camera);
			const intersects = raycaster.intersectObjects(objects, false);
			if (intersects.length > 0) {
				const intersect = intersects[0];
				rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
				rollOverMesh.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
			}
			render();
		}

		function onPointerDown(event) {
			pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(pointer, camera);
			const intersects = raycaster.intersectObjects(objects, false);
			if (intersects.length > 0) {
				const intersect = intersects[0];
				// delete cube
				if (isShiftDown) {
					if (intersect.object !== plane) {
						scene.remove(intersect.object);
						objects.splice(objects.indexOf(intersect.object), 1);
					}
					// create cube
				} else {
					const voxel = new THREE.Mesh(cubeGeo, cubeMaterial);
					voxel.position.copy(intersect.point).add(intersect.face.normal);
					voxel.position.divideScalar(50).floor().multiplyScalar(50).addScalar(25);
					scene.add(voxel);
					objects.push(voxel);
				}
				render();
			}
		}

		function onDocumentKeyDown(event) {
			switch (event.keyCode) {
				case 16: isShiftDown = true; break;
			}
		}

		function onDocumentKeyUp(event) {
			switch (event.keyCode) {
				case 16: isShiftDown = false; break;
			}
		}

		function render() {
			renderer.render(scene, camera);
		}

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.target.set(0, 12, 0);
		controls.update();

	</script>

</body>

</html>