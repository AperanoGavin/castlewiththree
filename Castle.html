<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
	</head>
	<body>

		<script type="module">

			import * as THREE from '../three.js/build/three.module.js';

			import { OrbitControls } from '../three.js/examples/jsm/controls/OrbitControls.js';	
			import { CameraControls } from '../three.js/examples/jsm/controls/experimental/CameraControls.js';


			let camera, scene, renderer;
			let plane;
			let pointer, raycaster, isShiftDown = false;

			let rollOverMesh, rollOverMaterial;
			let cubeGeo, cubeMaterial;

			const TextureLoader = new THREE.TextureLoader();
			const grass = TextureLoader.load( 'textures/grass.jpg' );
			const brick = TextureLoader.load( '../three.js/examples/textures/brick_bump.jpg' );
			const redbrick = TextureLoader.load('textures/Roof_Tiles_Terracotta_006_basecolor.jpg');
			const sky = TextureLoader.load('textures/sky.jpg')
			const objects = [];

			init();
			render();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
				scene.background = sky;
				
				//south wall
				let x = -500;
				let y = 25;
				let z = 525;
				for(var i = 0; i<3; i++){
					for(var j = 0; j<21; j++){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						if(j>6 && j<14){
							if(j==7 || j==13){
							const material = new THREE.MeshLambertMaterial( {map: brick} );
							const cube = new THREE.Mesh( wall, material );
							cube.position.set(x+25,y,z)
							scene.add( cube );
							}
						}else{
							const material = new THREE.MeshLambertMaterial( {map:brick} );
							const cube = new THREE.Mesh( wall, material );
							cube.position.set(x+25,y,z)
							scene.add( cube );
						}
						x=x+50;
					}
					x=-500;
					y=y+50;
				}
				let indent = 1;
				for(var j = 0; j<21; j++){
					if(indent%2!=0){
							if(j!=8 && j!=10 && j!= 12){
								const wall = new THREE.BoxGeometry( 50, 50, 50 );
								const material = new THREE.MeshLambertMaterial( {map:brick} );
								const cube = new THREE.Mesh( wall, material );
								cube.position.set(x+25,y,z);
								x=x+50;
								scene.add( cube );
								indent+=1;
							}else{
								x=x+50;
								indent+=1;
							}
					}else{
						indent+=1;
						x=x+50
						continue;
					}
					
				}
				

				//north wall
				x = -500;
				y = 25;
				z = -575;
				for(var i = 0; i<3; i++){
					for(var j = 0; j<21; j++){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x+25,y,z);
						x=x+50;
						scene.add( cube );
					}
					x=-500;
					y=y+50;
				}
				indent = 1;
				for(var j = 0; j<21; j++){
					if(indent%2!=0){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x+25,y,z);
						x=x+50;
						scene.add( cube );
						indent+=1;
					}else{
						indent+=1;
						x=x+50
						continue;
					}
				}
				

				//west wall
				x = -475;
				y = 25;
				z = -525;
				for(var i = 0; i<3; i++){
					for(var j = 0; j<21; j++){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x,y,z);
						z=z+50;
						scene.add( cube );
					}
					z=-525;
					y=y+50;
				}
				indent = 1;
				for(var j = 0; j<21; j++){
					if(indent%2==0){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x,y,z);
						z=z+50;
						scene.add( cube );
						indent+=1;
					}else{
						indent+=1;
						z=z+50
						continue;
					}
						
				}

				//east wall
				x = 525;
				y = 25;
				z = -525;
				for(var i = 0; i<3; i++){
					for(var j = 0; j<21; j++){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x,y,z)
						z=z+50
						scene.add( cube );
					}
					z=-525
					y=y+50
				}
				for(var j = 0; j<21; j++){
					if(indent%2!=0){
						const wall = new THREE.BoxGeometry( 50, 50, 50 );
						const material = new THREE.MeshLambertMaterial( {map:brick} );
						const cube = new THREE.Mesh( wall, material );
						cube.position.set(x,y,z);
						z=z+50;
						scene.add( cube );
						indent+=1;
					}else{
						indent+=1;
						z=z+50
						continue;
					}
						
				}

				//south west tower
				x=-400
				y=50*5/2	
				z=450
				const SWtower = new THREE.CylinderGeometry( 50, 50, 50*5, 320 );
				const material = new THREE.MeshLambertMaterial( { map: brick } );
				const roof = new THREE.MeshLambertMaterial( {map: redbrick} );
				const SWcylinder = new THREE.Mesh( SWtower, material );
				SWcylinder.position.set(x,y,z);
				scene.add( SWcylinder );
				y=y+225
				const SWcone = new THREE.ConeGeometry( 80, 200, 320 );
				const SWroof = new THREE.Mesh( SWcone, roof );
				SWroof.position.set(x,y,z);
				scene.add( SWroof );

				//south east tower
				x=450
				y=50*5/2	
				z=450
				const SEtower = new THREE.CylinderGeometry( 50, 50, 50*5, 320 );
				const SEcylinder = new THREE.Mesh( SEtower, material );
				SEcylinder.position.set(x,y,z);
				scene.add( SEcylinder );
				y=y+225
				const SEcone = new THREE.ConeGeometry( 80, 200, 320 );
				const SEroof = new THREE.Mesh( SEcone, roof );
				SEroof.position.set(x,y,z);
				scene.add( SEroof );
				
				//north east tower
				x=450
				y=50*5/2	
				z=-500
				const NEtower = new THREE.CylinderGeometry( 50, 50, 50*5, 320 );
				const NEcylinder = new THREE.Mesh( NEtower, material );
				NEcylinder.position.set(x,y,z);
				scene.add( NEcylinder );
				y=y+225
				const NEcone = new THREE.ConeGeometry( 80, 200, 320 );
				const NEroof = new THREE.Mesh( NEcone, roof );
				NEroof.position.set(x,y,z);
				scene.add( NEroof );
				
				//north west tower
				x=-400
				y=50*5/2	
				z=-500
				const NWtower = new THREE.CylinderGeometry( 50, 50, 50*5, 320 );
				const NWcylinder = new THREE.Mesh( NWtower, material );
				NWcylinder.position.set(x,y,z);
				scene.add( NWcylinder );
				y=y+225
				const NWcone = new THREE.ConeGeometry( 80, 200, 320 );
				const NWroof = new THREE.Mesh( NWcone, roof );
				NWroof.position.set(x,y,z);
				scene.add( NWroof );

				//central piece
				


				// roll-over helpers

				// const rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
				// rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				// rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				// scene.add( rollOverMesh );

				// cubes

				// cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				// cubeMaterial = new THREE.MeshLambertMaterial( { map: brick } );

				// grid

				// const gridHelper = new THREE.GridHelper( 1500, 20 );
				// scene.add( gridHelper );

				//

				raycaster = new THREE.Raycaster();
				pointer = new THREE.Vector2();

				const ground = new THREE.PlaneGeometry( 1500, 1500 );
				ground.rotateX( - Math.PI / 2 );

				const geometry = new THREE.PlaneGeometry( 300, 300);
				geometry.rotateX( -Math.PI / 2 );
				x=-500
				y=0
				z=-500

				for(var i=0; i<5; i++){
					for(var j=0; j<5; j++){
						plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: grass } ));
					plane.position.set(x,y,z);
					scene.add( plane );
					x=x+250
					}
					x=-500
					z=z+250
				}
				
				

				objects.push( plane );

				// lights

				const ambientLight = new THREE.AmbientLight( 0x606060 );
				scene.add( ambientLight );

				const directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				document.addEventListener( 'pointermove', onPointerMove );
				document.addEventListener( 'pointerdown', onPointerDown );
				document.addEventListener( 'keydown', onDocumentKeyDown );
				document.addEventListener( 'keyup', onDocumentKeyUp );

				//

				window.addEventListener( 'resize', onWindowResize );
				
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function onPointerMove( event ) {

				pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( objects, false );

				if ( intersects.length > 0 ) {

					const intersect = intersects[ 0 ];

					rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

				}

				render();

			}

			function onPointerDown( event ) {

				pointer.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( objects, false );

				if ( intersects.length > 0 ) {

					const intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object !== plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

						// create cube

					} else {

						const voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );

					}

					render();

				}

			}

			function onDocumentKeyDown( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = true; break;

				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;

				}

			}

			function render() {

				renderer.render( scene, camera );

			}

			const controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 12, 0 );
				controls.update();


		</script>

	</body>
</html>
