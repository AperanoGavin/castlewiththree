<!DOCTYPE html>
<html lang="en">

<head>
	<title>Castle</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>

<body>

	<script type="module">

		import * as THREE from '../three.js/build/three.module.js';
		import { OrbitControls } from '../three.js/examples/jsm/controls/OrbitControls.js';
		import { CameraControls } from '../three.js/examples/jsm/controls/experimental/CameraControls.js';
		import { GUI } from '../three.js/examples/jsm/libs/dat.gui.module.js';

		let camera, scene, renderer;
		let plane, road, door, gate, castleWindow, court;
		let pointer, raycaster, spotLight;
		let cubeGeo, cubeMaterial;
		let gui;

		const TextureLoader = new THREE.TextureLoader();

		const grass = TextureLoader.load('textures/grass.jpg');
		const brick = TextureLoader.load('../three.js/examples/textures/brick_bump.jpg');
		const redbrick = TextureLoader.load('textures/Roof_Tiles_Terracotta_006_basecolor.jpg');
		const sky = TextureLoader.load('textures/sky.jpg');
		const paving = TextureLoader.load('textures/floor.jpg');
		const woodenDoor = TextureLoader.load('textures/door.png');
		const guardGateTexture = TextureLoader.load('textures/gate.png');
		const windowTexture = TextureLoader.load('textures/window.png');
		const courtTexture = TextureLoader.load('textures/stone.png');

		const tiles = new THREE.MeshPhongMaterial({ map: redbrick });
		const material = new THREE.MeshPhongMaterial({ map: brick });
		const guardGate = new THREE.MeshPhongMaterial({ map: guardGateTexture, transparent: true });

		const objects = [];

		let x, y, z;

		init();
		render();
		buildGui();

		function init() {
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(500, 800, 1300);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = sky;

			//south wall
			x = -500;
			y = 25;
			z = 525;
			createWall(x, y, z, "south", 21, 3);

			//north wall
			x = -500;
			y = 25;
			z = -575;
			createWall(x, y, z, "north", 21, 3);

			//west wall
			x = -475;
			y = 25;
			z = -525;
			createWall(x, y, z, "west", 21, 3);

			//east wall
			x = 525;
			y = 25;
			z = -525;
			createWall(x, y, z, "east", 21, 3);

			//south west tower
			x = -400;
			y = 50 * 5 / 2;
			z = 450;
			createTower(x, y, z);

			//south east tower
			x = 450;
			y = 50 * 5 / 2;
			z = 450;
			createTower(x, y, z);

			//north east tower
			x = 450;
			y = 50 * 5 / 2;
			z = -500;
			createTower(x, y, z);

			//north west tower
			x = -400;
			y = 50 * 5 / 2;
			z = -500;
			createTower(x, y, z);

			//central piece
			x = -250;
			y = 25;
			z = -250;
			createWall(x, y, z, "north", 11, 6);

			x = -250;
			y = 25;
			z = 250;
			createWall(x, y, z, "south", 3, 6);
			x = 150;
			y = 25;
			z = 250;
			createWall(x, y, z, "south", 3, 6);

			x = -275;
			y = 25;
			z = -250;
			createWall(x, y, z, "west", 11, 6);

			x = 325;
			y = 25;
			z = -250;
			createWall(x, y, z, "east", 11, 6);

			//central tower
			x = -125;
			y = 25;
			z = -150;
			createWall(x, y, z, "north", 6, 11, "no");

			x = 180;
			y = 25;
			z = -125;
			createWall(x, y, z, "east", 6, 11, "no");

			x = -125;
			y = 25;
			z = -125;
			createWall(x, y, z, "west", 6, 11, "no");

			x = -125;
			y = 25;
			z = 150;
			createWall(x, y, z, "south", 6, 11, "no");

			//central pyramidal roof
			x = 25;
			y = 625;
			z = 0;
			const pyramidRoofGeo = new THREE.CylinderGeometry(1, 50 * 6, 50 * 4, 4);
			const pyramidRoof = new THREE.Mesh(pyramidRoofGeo, tiles);
			pyramidRoof.rotateY(-Math.PI / 4);
			pyramidRoof.position.set(25, 625, 0);
			scene.add(pyramidRoof);



			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();

			const grassGeo = new THREE.BoxGeometry(300, 300, 2);
			grassGeo.rotateX(-Math.PI / 2);
			x = -600;
			y = 0;
			z = -600;

			// const gridHelper = new THREE.GridHelper(1500, 25);
			// gridHelper.position.set(0, 0, 0);
			// scene.add(gridHelper);

			for (var i = 0; i < 5; i++) {
				for (var j = 0; j < 5; j++) {
					plane = new THREE.Mesh(grassGeo, new THREE.MeshPhongMaterial({ map: grass }));
					plane.position.set(x, y, z);
					if (j % 2 == 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0 && j % 2 != 0) {
						plane.rotateY(Math.PI);
					}

					scene.add(plane);
					x = x + 300;
				}

				x = -600;
				z = z + 300;
			}
			objects.push(plane);


			// const courtGeo = new THREE.PlaneGeometry(250, 300);
			// court = new THREE.Mesh(courtGeo, new THREE.MeshPhongMaterial({ map: courtTexture }));
			// court.position.set(-175, 3, -100);
			// courtGeo.rotateX(-Math.PI / 2);
			// scene.add(court);


			const roadGeo = new THREE.PlaneGeometry(250, 300);
			roadGeo.rotateX(-Math.PI / 2);
			x = 25;
			y = 2;
			z = 600;

			for (var i = 0; i < 2; i++) {
				road = new THREE.Mesh(roadGeo, new THREE.MeshPhongMaterial({ map: paving }));
				road.position.set(x, y, z);
				scene.add(road);
				z = z - 300;
			}

			const doorGeo = new THREE.PlaneGeometry(200, 200);
			x = 25;
			y = 100;
			z = 176;
			door = new THREE.Mesh(doorGeo, new THREE.MeshPhongMaterial({ map: woodenDoor }));
			door.position.set(x, y, z);
			scene.add(door);

			// const gateGeo = new THREE.BoxGeometry(300, 300, 50);
			// const gateFrame = [
			// 	material,
			// 	material,
			// 	material,
			// 	material,
			// 	guardGate,
			// 	guardGate
			// ]
			// gate = new THREE.Mesh(gateGeo, gateFrame);
			// gate.position.set(x, y + 50, z + 350);
			// scene.add(gate);


			createWindow(x, y + 300, z, 200, 200, "south");
			createWindow(x, y + 300, z - 352, 200, 200, "north");
			createWindow(x + 181, y + 300, z - 172, 200, 200, "east");
			createWindow(x - 176, y + 300, z - 172, 200, 200, "west");

			//lights
			const ambientLight = new THREE.AmbientLight(0x606060, 0.1);
			scene.add(ambientLight);

			spotLight = new THREE.SpotLight(0xffffff, 0.5);
			spotLight.position.set(-1000, 1500, 1000);
			spotLight.castShadow = true;
			spotLight.shadow.mapSize.width = 512;
			spotLight.shadow.mapSize.height = 512;
			spotLight.shadow.camera.near = 10;
			spotLight.shadow.camera.far = 200;
			spotLight.shadow.focus = 1;
			scene.add(spotLight);


			var spotLight2 = new THREE.SpotLight(0xadd8e6, 1);
			spotLight2.position.set(0, 1500, 1000);
			spotLight2.castShadow = true;
			spotLight2.shadow.mapSize.width = 512;
			spotLight2.shadow.mapSize.height = 512;
			spotLight2.shadow.camera.near = 10;
			spotLight2.shadow.camera.far = 200;
			spotLight2.shadow.focus = 1;
			scene.add(spotLight2);

			var lightHelper = new THREE.SpotLightHelper(spotLight, 5);
			scene.add(lightHelper);

			var lightHelper2 = new THREE.SpotLightHelper(spotLight2, 5);
			scene.add(lightHelper2);

			var shadowCameraHelper = new THREE.CameraHelper(spotLight.shadow.camera);
			scene.add(shadowCameraHelper);


			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			renderer.outputEncoding = THREE.sRGBEncoding;

			document.body.appendChild(renderer.domElement);
			document.addEventListener('pointermove', onPointerMove);

			window.addEventListener('resize', onWindowResize);
		}

		function buildGui() {

			gui = new GUI();

			const params = {
				'light color': spotLight.color.getHex(),
				intensity: spotLight.intensity,
				distance: spotLight.distance,
				angle: spotLight.angle,
				penumbra: spotLight.penumbra,
				decay: spotLight.decay,
				focus: spotLight.shadow.focus
			};

			gui.addColor(params, 'light color').onChange(function (val) {

				spotLight.color.setHex(val);
				render();

			});

			gui.add(params, 'intensity', 0, 2).onChange(function (val) {

				spotLight.intensity = val;
				render();

			});


			gui.add(params, 'distance', 50, 200).onChange(function (val) {

				spotLight.distance = val;
				render();

			});

			gui.add(params, 'angle', 0, Math.PI / 3).onChange(function (val) {

				spotLight.angle = val;
				render();

			});

			gui.add(params, 'penumbra', 0, 1).onChange(function (val) {

				spotLight.penumbra = val;
				render();

			});

			gui.add(params, 'decay', 1, 2).onChange(function (val) {

				spotLight.decay = val;
				render();

			});

			gui.add(params, 'focus', 0, 1).onChange(function (val) {

				spotLight.shadow.focus = val;
				render();

			});

			gui.open();

		}


		function createWindow(x, y, z, height, width, direction) {
			const windowGeo = new THREE.PlaneGeometry(height, width);
			castleWindow = new THREE.Mesh(windowGeo, new THREE.MeshPhongMaterial({ map: windowTexture, transparent: true }));
			console.log(direction);
			switch (direction) {
				case 'south':
					castleWindow.position.set(x, y, z);
					scene.add(castleWindow);
					break;

				case 'north':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(-Math.PI);
					scene.add(castleWindow);
					break;

				case 'east':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(Math.PI / 2);
					scene.add(castleWindow);
					break;

				case 'west':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(-Math.PI / 2);
					scene.add(castleWindow);
					break;

				default:
					console.log("wrond window direction value");
			}

		}

		function createWall(x, y, z, side, length, height, noIndent) {
			console.log(noIndent);
			let indent;
			let xstart = x;
			let zstart = z;
			switch (side) {
				case 'north':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x + 25, y, z);
							x = x + 50;
							scene.add(cube);
						}
						x = xstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z);
								x = x + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								x = x + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'west':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z);
							z = z + 50;
							scene.add(cube);
						}
						z = zstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 == 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x, y, z);
								z = z + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								z = z + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'east':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z)
							z = z + 50
							scene.add(cube);
						}
						z = zstart
						y = y + 50
					}
					if (noIndent === undefined) {
						indent = 0;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x, y, z);
								z = z + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								z = z + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'south':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							if (j > 6 && j < 14) {
								if (j == 7 || j == 13) {
									const cube = new THREE.Mesh(wall, material);
									cube.position.set(x + 25, y, z)
									scene.add(cube);
								}
							} else {
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z)
								scene.add(cube);
							}
							x = x + 50;
						}
						x = xstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								if (j != 8 && j != 10 && j != 12) {
									const wall = new THREE.BoxGeometry(50, 50, 50);
									const cube = new THREE.Mesh(wall, material);
									cube.position.set(x + 25, y, z);
									x = x + 50;
									scene.add(cube);
									indent += 1;
								} else {
									x = x + 50;
									indent += 1;
								}
							} else {
								indent += 1;
								x = x + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				default:
					console.log("side not recognized")
			}
		}

		function createTower(x, y, z) {
			const tower = new THREE.CylinderGeometry(50, 50, 50 * 5, 320);
			const cylinder = new THREE.Mesh(tower, material);
			cylinder.position.set(x, y, z);
			scene.add(cylinder);
			y = y + 225
			const cone = new THREE.ConeGeometry(80, 200, 320);
			const roof = new THREE.Mesh(cone, tiles);
			roof.position.set(x, y, z);
			scene.add(roof);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();

		}

		function onPointerMove(event) {
			pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(pointer, camera);
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}

		// var zoomEnd = 0;
		// this.zoomStart = 0;

		// this.zoomDampingFactor = 0.2; //0.3
		// this.smoothZoomSpeed = 5.0;
		// this.smoothZoom = false;

		// this.smoothZoomUpdate = function () {

		// 	var factor = 1.0 + (zoomEnd - this.zoomStart) * this.smoothZoomSpeed;
		// 	scale *= factor;

		// 	this.zoomStart += (zoomEnd - this.zoomStart) * this.zoomDampingFactor;

		// };
		const controls = new OrbitControls(camera, renderer.domElement);
		controls.target.set(0, 12, 0);
		// controls.constraint.smoothZoom = true;
		// controls.constraint.zoomDampingFactor = 0.2;
		// controls.constraint.smoothZoomSpeed = 5.0;
		controls.update();

	</script>

</body>

</html>